from fastapi import APIRouter, HTTPException, Depends, Request
from fastapi.responses import JSONResponse, RedirectResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
import os
from datetime import datetime, timedelta
from typing import Optional, Dict
import httpx
import jwt
import bcrypt
from app.core.db import get_db, is_postgres_connection

router = APIRouter(prefix="/auth", tags=["auth"])

JWT_SECRET = os.getenv("JWT_SECRET", "dev-secret-change-me")
JWT_ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
JWT_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID", "")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET", "")
GOOGLE_REDIRECT_URI = os.getenv("GOOGLE_REDIRECT_URI", "http://127.0.0.1:8000/api/auth/google/callback")
FRONTEND_BASE_URL = os.getenv("FRONTEND_BASE_URL", "http://127.0.0.1:5500/src/index.html")

security = HTTPBearer(auto_error=True)

# Versão tolerante (não obriga header) para permitir cookie OU header
optional_security = HTTPBearer(auto_error=False)


class GoogleAuthPayload(BaseModel):
    credential: Optional[str] = None  # id_token (JWT do Google)
    access_token: Optional[str] = None  # access_token OAuth2 do Google


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=JWT_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)


def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    try:
        payload = jwt.decode(credentials.credentials, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        email = payload.get("sub")
        if not email:
            raise HTTPException(status_code=401, detail="Token inválido")
        return email
    except Exception:
        raise HTTPException(status_code=401, detail="Token inválido")


def get_current_user(
    request: Request,
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(optional_security),
) -> Dict:
    """Obtém o usuário atual a partir do Authorization: Bearer ou cookie HttpOnly.

    Retorna o payload do JWT se válido, ou lança HTTP 401 caso contrário.
    """
    token: Optional[str] = None
    if credentials and credentials.scheme and credentials.scheme.lower() == "bearer":
        token = credentials.credentials
    if not token:
        token = request.cookies.get("app_token")
    if not token:
        raise HTTPException(status_code=401, detail="Não autenticado")

    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        email = payload.get("sub")
        if not email:
            raise HTTPException(status_code=401, detail="Token inválido")
        return payload
    except Exception:
        raise HTTPException(status_code=401, detail="Token inválido")
class RegisterIn(BaseModel):
    email: str
    password: str
    full_name: str


class LoginIn(BaseModel):
    email: str
    password: str


def _hash_password(plain: str) -> str:
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(plain.encode("utf-8"), salt).decode("utf-8")


def _verify_password(plain: str, hashed: str) -> bool:
    try:
        return bcrypt.checkpw(plain.encode("utf-8"), hashed.encode("utf-8"))
    except Exception:
        return False


def _ensure_users_table(conn) -> None:
    """Cria tabela users se não existir (campos mínimos).
    Usa PostgreSQL quando disponível; ignora em MySQL se não necessário.
    """
    try:
        if is_postgres_connection(conn):
            with conn.cursor() as cur:  # type: ignore[attr-defined]
                cur.execute(
                    """
                    CREATE TABLE IF NOT EXISTS users (
                      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                      email VARCHAR(255) UNIQUE NOT NULL,
                      password_hash VARCHAR(255) NOT NULL,
                      full_name VARCHAR(255) NULL,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
        else:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    CREATE TABLE IF NOT EXISTS users (
                      id INT AUTO_INCREMENT PRIMARY KEY,
                      email VARCHAR(255) UNIQUE NOT NULL,
                      password_hash VARCHAR(255) NOT NULL,
                      full_name VARCHAR(255) NULL,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                    """
                )
    except Exception:
        pass


@router.post("/register")
def register(payload: RegisterIn, db = Depends(get_db)):
    if not payload.email or not payload.password or not payload.full_name:
        raise HTTPException(status_code=400, detail="Dados inválidos")
    if len(payload.password) < 6:
        raise HTTPException(status_code=400, detail="Senha muito curta")

    _ensure_users_table(db)

    try:
        password_hash = _hash_password(payload.password)
        if is_postgres_connection(db):
            with db.cursor() as cur:  # type: ignore[attr-defined]
                cur.execute("SELECT 1 FROM users WHERE email=%s", (payload.email,))
                if cur.fetchone():
                    raise HTTPException(status_code=400, detail="Email já cadastrado")
                cur.execute(
                    "INSERT INTO users (email, password_hash, full_name) VALUES (%s, %s, %s) RETURNING id",
                    (payload.email, password_hash, payload.full_name),
                )
                row = cur.fetchone()
                user_id = row["id"] if isinstance(row, dict) else row[0]
        else:
            with db.cursor() as cur:
                cur.execute("SELECT 1 FROM users WHERE email=%s", (payload.email,))
                if cur.fetchone():
                    raise HTTPException(status_code=400, detail="Email já cadastrado")
                cur.execute(
                    "INSERT INTO users (email, password_hash, full_name) VALUES (%s, %s, %s)",
                    (payload.email, password_hash, payload.full_name),
                )
                user_id = cur.lastrowid
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=500, detail="Erro ao registrar usuário")

    token = create_access_token({"sub": payload.email, "name": payload.full_name, "provider": "local"})
    return JSONResponse(content={"success": True, "token": token, "user": {"id": user_id, "email": payload.email, "name": payload.full_name}})


@router.post("/login")
def login(payload: LoginIn, db = Depends(get_db)):
    if not payload.email or not payload.password:
        raise HTTPException(status_code=400, detail="Dados inválidos")

    try:
        if is_postgres_connection(db):
            with db.cursor() as cur:  # type: ignore[attr-defined]
                cur.execute("SELECT id, email, password_hash, full_name FROM users WHERE email=%s", (payload.email,))
                row = cur.fetchone()
        else:
            with db.cursor() as cur:
                cur.execute("SELECT id, email, password_hash, full_name FROM users WHERE email=%s", (payload.email,))
                row = cur.fetchone()
        if not row:
            raise HTTPException(status_code=401, detail="Credenciais inválidas")
        password_hash = row["password_hash"] if isinstance(row, dict) else row[2]
        if not _verify_password(payload.password, password_hash):
            raise HTTPException(status_code=401, detail="Credenciais inválidas")
        full_name = row["full_name"] if isinstance(row, dict) else row[3]
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=500, detail="Erro ao autenticar")

    token = create_access_token({"sub": payload.email, "name": full_name, "provider": "local"})
    return JSONResponse(content={"success": True, "token": token, "user": {"email": payload.email, "name": full_name}})



@router.post("/google")
async def auth_google(payload: GoogleAuthPayload, request: Request):
    if not payload.credential and not payload.access_token:
        raise HTTPException(status_code=400, detail="Informe credential (id_token) ou access_token")

    user_info: Optional[dict] = None

    async with httpx.AsyncClient(timeout=8.0) as client:
        # Preferir validar id_token quando disponível
        if payload.credential:
            # Validação via tokeninfo do Google
            r = await client.get("https://oauth2.googleapis.com/tokeninfo", params={"id_token": payload.credential})
            if r.status_code != 200:
                raise HTTPException(status_code=401, detail="id_token inválido")
            data = r.json()
            aud = data.get("aud")
            email = data.get("email")
            email_verified = data.get("email_verified") in (True, "true", "1", 1)
            name = data.get("name")
            picture = data.get("picture")

            if GOOGLE_CLIENT_ID and aud != GOOGLE_CLIENT_ID:
                raise HTTPException(status_code=401, detail="id_token não corresponde ao client_id")
            if not email or not email_verified:
                raise HTTPException(status_code=401, detail="Email não verificado")

            user_info = {"email": email, "name": name, "picture": picture, "sub": data.get("sub")}

        elif payload.access_token:
            # Obter dados do usuário via userinfo endpoint
            r = await client.get(
                "https://www.googleapis.com/oauth2/v3/userinfo",
                headers={"Authorization": f"Bearer {payload.access_token}"}
            )
            if r.status_code != 200:
                raise HTTPException(status_code=401, detail="access_token inválido")
            data = r.json()
            email = data.get("email")
            email_verified = data.get("email_verified") in (True, "true", "1", 1)
            if not email or not email_verified:
                raise HTTPException(status_code=401, detail="Email não verificado")
            user_info = {
                "email": email,
                "name": data.get("name"),
                "picture": data.get("picture"),
                "sub": data.get("sub"),
            }

    # Emite nosso JWT
    claims = {
        "sub": user_info["email"],
        "name": user_info.get("name"),
        "picture": user_info.get("picture"),
        "provider": "google",
    }
    token = create_access_token(claims)

    return JSONResponse(content={
        "success": True,
        "token": token,
        "user": user_info,
    })


@router.get("/google/login")
async def google_login():
    if not GOOGLE_CLIENT_ID:
        raise HTTPException(status_code=500, detail="GOOGLE_CLIENT_ID não configurado")

    auth_url = (
        "https://accounts.google.com/o/oauth2/v2/auth"
        f"?client_id={GOOGLE_CLIENT_ID}"
        f"&redirect_uri={httpx.QueryParams({'redirect_uri': GOOGLE_REDIRECT_URI})['redirect_uri']}"
        "&response_type=code"
        "&scope=openid%20email%20profile"
        "&access_type=online"
        "&prompt=consent"
    )
    return RedirectResponse(url=auth_url, status_code=302)


@router.get("/google/callback")
async def google_callback(code: Optional[str] = None, error: Optional[str] = None):
    if error:
        raise HTTPException(status_code=400, detail=f"Erro no login Google: {error}")
    if not code:
        raise HTTPException(status_code=400, detail="Código de autorização ausente")
    if not (GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET):
        raise HTTPException(status_code=500, detail="Credenciais do Google ausentes")

    async with httpx.AsyncClient(timeout=8.0) as client:
        token_res = await client.post(
            "https://oauth2.googleapis.com/token",
            data={
                "code": code,
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "redirect_uri": GOOGLE_REDIRECT_URI,
                "grant_type": "authorization_code",
            },
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        if token_res.status_code != 200:
            raise HTTPException(status_code=401, detail="Falha ao trocar código por token")
        token_json = token_res.json()
        id_token = token_json.get("id_token")
        access_token = token_json.get("access_token")
        if not id_token and not access_token:
            raise HTTPException(status_code=401, detail="Token inválido do Google")

        # Preferir validar id_token
        user_info: Optional[dict] = None
        if id_token:
            r = await client.get("https://oauth2.googleapis.com/tokeninfo", params={"id_token": id_token})
            if r.status_code != 200:
                raise HTTPException(status_code=401, detail="id_token inválido")
            data = r.json()
            if data.get("aud") != GOOGLE_CLIENT_ID:
                raise HTTPException(status_code=401, detail="audience inválida")
            if data.get("email_verified") not in (True, "true", "1", 1):
                raise HTTPException(status_code=401, detail="Email não verificado")
            user_info = {
                "email": data.get("email"),
                "name": data.get("name"),
                "picture": data.get("picture"),
                "sub": data.get("sub"),
            }
        else:
            ui = await client.get(
                "https://www.googleapis.com/oauth2/v3/userinfo",
                headers={"Authorization": f"Bearer {access_token}"}
            )
            if ui.status_code != 200:
                raise HTTPException(status_code=401, detail="Falha ao obter userinfo")
            data = ui.json()
            if data.get("email_verified") not in (True, "true", "1", 1):
                raise HTTPException(status_code=401, detail="Email não verificado")
            user_info = {
                "email": data.get("email"),
                "name": data.get("name"),
                "picture": data.get("picture"),
                "sub": data.get("sub"),
            }

    claims = {
        "sub": user_info["email"],
        "name": user_info.get("name"),
        "picture": user_info.get("picture"),
        "provider": "google",
    }
    token = create_access_token(claims)

    # Seta cookie HttpOnly com o JWT e redireciona para o frontend
    response = RedirectResponse(url=FRONTEND_BASE_URL, status_code=302)
    # Em dev, secure=False; em prod, ajuste para True
    response.set_cookie(
        key="app_token",
        value=token,
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=JWT_EXPIRE_MINUTES * 60,
        path="/"
    )
    return response


@router.get("/me")
async def me(user: Dict = Depends(get_current_user)):
    return JSONResponse(content={
        "success": True,
        "user": {
            "email": user.get("sub"),
            "name": user.get("name"),
            "picture": user.get("picture"),
            "provider": user.get("provider"),
        }
    })


@router.post("/logout")
async def logout():
    # Responde com JSON e apaga cookie HttpOnly
    response = JSONResponse(content={"success": True, "message": "Logout efetuado"})
    response.delete_cookie(key="app_token", path="/", samesite="lax")
    return response

