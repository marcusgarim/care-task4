from fastapi import APIRouter, HTTPException, Depends, Request
from fastapi.responses import JSONResponse, RedirectResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
import os
from datetime import datetime, timedelta
from typing import Optional, Dict
import httpx
import jwt
import bcrypt
from app.core.db import get_db, is_postgres_connection

router = APIRouter(prefix="/auth", tags=["auth"])

JWT_SECRET = os.getenv("JWT_SECRET", "dev-secret-change-me")
JWT_ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
JWT_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID", "")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET", "")
GOOGLE_REDIRECT_URI = os.getenv("GOOGLE_REDIRECT_URI", "http://127.0.0.1:8000/api/auth/google/callback")
FRONTEND_BASE_URL = os.getenv("FRONTEND_BASE_URL", "http://127.0.0.1:5500/src/index.html")

security = HTTPBearer(auto_error=True)

# Versão tolerante (não obriga header) para permitir cookie OU header
optional_security = HTTPBearer(auto_error=False)


class GoogleAuthPayload(BaseModel):
    credential: Optional[str] = None  # id_token (JWT do Google)
    access_token: Optional[str] = None  # access_token OAuth2 do Google


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=JWT_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)


def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    try:
        # Permitir token de teste para desenvolvimento
        if credentials.credentials == "test-token":
            return "test@example.com"
            
        payload = jwt.decode(credentials.credentials, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        email = payload.get("sub")
        if not email:
            raise HTTPException(status_code=401, detail="Token inválido")
        return email
    except Exception:
        raise HTTPException(status_code=401, detail="Token inválido")


def get_current_user(
    request: Request,
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(optional_security),
) -> Dict:
    """Obtém o usuário atual a partir do Authorization: Bearer OU cookie HttpOnly.

    Tenta validar Bearer; se falhar, tenta o cookie `app_token` antes de retornar 401.
    """
    header_token: Optional[str] = None
    if credentials and credentials.scheme and credentials.scheme.lower() == "bearer":
        header_token = credentials.credentials
    cookie_token: Optional[str] = request.cookies.get("app_token")

    for candidate in [header_token, cookie_token]:
        if not candidate:
            continue
        try:
            # Permitir token de teste para desenvolvimento
            if candidate == "test-token":
                return {"sub": "test@example.com", "is_admin": True, "ativo": True}
                
            payload = jwt.decode(candidate, JWT_SECRET, algorithms=[JWT_ALGORITHM])
            if payload.get("sub"):
                return payload
        except Exception:
            continue
    raise HTTPException(status_code=401, detail="Não autenticado")
class RegisterIn(BaseModel):
    email: str
    password: str
    full_name: str


class LoginIn(BaseModel):
    email: str
    password: str


def _hash_password(plain: str) -> str:
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(plain.encode("utf-8"), salt).decode("utf-8")


def _verify_password(plain: str, hashed: str) -> bool:
    try:
        return bcrypt.checkpw(plain.encode("utf-8"), hashed.encode("utf-8"))
    except Exception:
        return False


def _ensure_users_table(conn) -> None:
    """Cria tabela users se não existir e adiciona colunas de admin/ativo."""
    try:
        if is_postgres_connection(conn):
            with conn.cursor() as cur:  # type: ignore[attr-defined]
                cur.execute(
                    """
                    CREATE TABLE IF NOT EXISTS users (
                      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                      email VARCHAR(255) UNIQUE NOT NULL,
                      password_hash VARCHAR(255) NOT NULL,
                      full_name VARCHAR(255) NULL,
                      google_id VARCHAR(255) NULL,
                      photo_url VARCHAR(512) NULL,
                      is_admin BOOLEAN DEFAULT FALSE,
                      ativo BOOLEAN DEFAULT TRUE,
                      last_access TIMESTAMP NULL,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                # Adicionar colunas se necessário
                cur.execute("ALTER TABLE users ADD COLUMN IF NOT EXISTS google_id VARCHAR(255)")
                cur.execute("ALTER TABLE users ADD COLUMN IF NOT EXISTS photo_url VARCHAR(512)")
                cur.execute("ALTER TABLE users ADD COLUMN IF NOT EXISTS is_admin BOOLEAN DEFAULT FALSE")
                cur.execute("ALTER TABLE users ADD COLUMN IF NOT EXISTS ativo BOOLEAN DEFAULT TRUE")
                cur.execute("ALTER TABLE users ADD COLUMN IF NOT EXISTS last_access TIMESTAMP NULL")
        else:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    CREATE TABLE IF NOT EXISTS users (
                      id INT AUTO_INCREMENT PRIMARY KEY,
                      email VARCHAR(255) UNIQUE NOT NULL,
                      password_hash VARCHAR(255) NOT NULL,
                      full_name VARCHAR(255) NULL,
                      google_id VARCHAR(255) NULL,
                      photo_url VARCHAR(512) NULL,
                      is_admin TINYINT(1) DEFAULT 0,
                      ativo TINYINT(1) DEFAULT 1,
                      last_access TIMESTAMP NULL,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                    """
                )
                # Tentar adicionar colunas (compatibilidade)
                for stmt in [
                    "ALTER TABLE users ADD COLUMN google_id VARCHAR(255)",
                    "ALTER TABLE users ADD COLUMN photo_url VARCHAR(512)",
                    "ALTER TABLE users ADD COLUMN is_admin TINYINT(1) DEFAULT 0",
                    "ALTER TABLE users ADD COLUMN ativo TINYINT(1) DEFAULT 1",
                    "ALTER TABLE users ADD COLUMN last_access TIMESTAMP NULL",
                ]:
                    try:
                        cur.execute(stmt)
                    except Exception:
                        pass
    except Exception:
        pass


@router.post("/register")
def register(payload: RegisterIn, db = Depends(get_db)):
    if not payload.email or not payload.password or not payload.full_name:
        raise HTTPException(status_code=400, detail="Dados inválidos")
    if len(payload.password) < 6:
        raise HTTPException(status_code=400, detail="Senha muito curta")

    _ensure_users_table(db)

    try:
        password_hash = _hash_password(payload.password)
        if is_postgres_connection(db):
            with db.cursor() as cur:  # type: ignore[attr-defined]
                cur.execute("SELECT 1 FROM users WHERE email=%s", (payload.email,))
                if cur.fetchone():
                    raise HTTPException(status_code=400, detail="Email já cadastrado")
                cur.execute(
                    "INSERT INTO users (email, password_hash, full_name) VALUES (%s, %s, %s) RETURNING id",
                    (payload.email, password_hash, payload.full_name),
                )
                row = cur.fetchone()
                user_id = row["id"] if isinstance(row, dict) else row[0]
        else:
            with db.cursor() as cur:
                cur.execute("SELECT 1 FROM users WHERE email=%s", (payload.email,))
                if cur.fetchone():
                    raise HTTPException(status_code=400, detail="Email já cadastrado")
                cur.execute(
                    "INSERT INTO users (email, password_hash, full_name) VALUES (%s, %s, %s)",
                    (payload.email, password_hash, payload.full_name),
                )
                user_id = cur.lastrowid
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=500, detail="Erro ao registrar usuário")

    token = create_access_token({"sub": payload.email, "name": payload.full_name, "provider": "local"})
    return JSONResponse(content={"success": True, "token": token, "user": {"id": user_id, "email": payload.email, "name": payload.full_name}})


@router.post("/login")
def login(payload: LoginIn, db = Depends(get_db)):
    if not payload.email or not payload.password:
        raise HTTPException(status_code=400, detail="Dados inválidos")

    try:
        if is_postgres_connection(db):
            with db.cursor() as cur:  # type: ignore[attr-defined]
                cur.execute("SELECT id, email, password_hash, full_name, is_admin, ativo FROM users WHERE email=%s", (payload.email,))
                row = cur.fetchone()
        else:
            with db.cursor() as cur:
                cur.execute("SELECT id, email, password_hash, full_name, is_admin, ativo FROM users WHERE email=%s", (payload.email,))
                row = cur.fetchone()
        if not row:
            raise HTTPException(status_code=401, detail="Credenciais inválidas")
        password_hash = row["password_hash"] if isinstance(row, dict) else row[2]
        is_admin_val = row["is_admin"] if isinstance(row, dict) else row[4]
        ativo_val = row["ativo"] if isinstance(row, dict) else row[5]
        if not (ativo_val in (True, 1)):
            raise HTTPException(status_code=403, detail="Usuário inativo")
        if not _verify_password(payload.password, password_hash):
            raise HTTPException(status_code=401, detail="Credenciais inválidas")
        full_name = row["full_name"] if isinstance(row, dict) else row[3]
        # Atualiza last_access (best-effort)
        try:
            with db.cursor() as cur2:
                cur2.execute("UPDATE users SET last_access = CURRENT_TIMESTAMP WHERE email=%s", (payload.email,))
        except Exception:
            pass
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=500, detail="Erro ao autenticar")

    token = create_access_token({"sub": payload.email, "name": full_name, "provider": "local"})
    resp = JSONResponse(content={"success": True, "token": token, "user": {"email": payload.email, "name": full_name, "is_admin": bool(is_admin_val), "ativo": bool(ativo_val)}})
    # Também grava cookie HttpOnly para facilitar validação via navegador
    try:
        resp.set_cookie(
            key="app_token",
            value=token,
            httponly=True,
            secure=False,
            samesite="lax",
            max_age=JWT_EXPIRE_MINUTES * 60,
            path="/",
        )
    except Exception:
        pass
    return resp



@router.post("/google")
async def auth_google(payload: GoogleAuthPayload, request: Request):
    if not payload.credential and not payload.access_token:
        raise HTTPException(status_code=400, detail="Informe credential (id_token) ou access_token")

    user_info: Optional[dict] = None

    async with httpx.AsyncClient(timeout=8.0) as client:
        # Preferir validar id_token quando disponível
        if payload.credential:
            # Validação via tokeninfo do Google
            r = await client.get("https://oauth2.googleapis.com/tokeninfo", params={"id_token": payload.credential})
            if r.status_code != 200:
                raise HTTPException(status_code=401, detail="id_token inválido")
            data = r.json()
            aud = data.get("aud")
            email = data.get("email")
            email_verified = data.get("email_verified") in (True, "true", "1", 1)
            name = data.get("name")
            picture = data.get("picture")

            if GOOGLE_CLIENT_ID and aud != GOOGLE_CLIENT_ID:
                raise HTTPException(status_code=401, detail="id_token não corresponde ao client_id")
            if not email or not email_verified:
                raise HTTPException(status_code=401, detail="Email não verificado")

            user_info = {"email": email, "name": name, "picture": picture, "sub": data.get("sub")}

        elif payload.access_token:
            # Obter dados do usuário via userinfo endpoint
            r = await client.get(
                "https://www.googleapis.com/oauth2/v3/userinfo",
                headers={"Authorization": f"Bearer {payload.access_token}"}
            )
            if r.status_code != 200:
                raise HTTPException(status_code=401, detail="access_token inválido")
            data = r.json()
            email = data.get("email")
            email_verified = data.get("email_verified") in (True, "true", "1", 1)
            if not email or not email_verified:
                raise HTTPException(status_code=401, detail="Email não verificado")
            user_info = {
                "email": email,
                "name": data.get("name"),
                "picture": data.get("picture"),
                "sub": data.get("sub"),
            }

    # Emite nosso JWT
    claims = {
        "sub": user_info["email"],
        "name": user_info.get("name"),
        "picture": user_info.get("picture"),
        "provider": "google",
    }
    token = create_access_token(claims)

    return JSONResponse(content={
        "success": True,
        "token": token,
        "user": user_info,
    })


@router.get("/google/login")
async def google_login():
    if not GOOGLE_CLIENT_ID:
        raise HTTPException(status_code=500, detail="GOOGLE_CLIENT_ID não configurado")

    auth_url = (
        "https://accounts.google.com/o/oauth2/v2/auth"
        f"?client_id={GOOGLE_CLIENT_ID}"
        f"&redirect_uri={httpx.QueryParams({'redirect_uri': GOOGLE_REDIRECT_URI})['redirect_uri']}"
        "&response_type=code"
        "&scope=openid%20email%20profile"
        "&access_type=online"
        "&prompt=consent"
    )
    return RedirectResponse(url=auth_url, status_code=302)


@router.get("/google/callback")
async def google_callback(code: Optional[str] = None, error: Optional[str] = None):
    if error:
        raise HTTPException(status_code=400, detail=f"Erro no login Google: {error}")
    if not code:
        raise HTTPException(status_code=400, detail="Código de autorização ausente")
    if not (GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET):
        raise HTTPException(status_code=500, detail="Credenciais do Google ausentes")

    async with httpx.AsyncClient(timeout=8.0) as client:
        token_res = await client.post(
            "https://oauth2.googleapis.com/token",
            data={
                "code": code,
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "redirect_uri": GOOGLE_REDIRECT_URI,
                "grant_type": "authorization_code",
            },
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        if token_res.status_code != 200:
            raise HTTPException(status_code=401, detail="Falha ao trocar código por token")
        token_json = token_res.json()
        id_token = token_json.get("id_token")
        access_token = token_json.get("access_token")
        if not id_token and not access_token:
            raise HTTPException(status_code=401, detail="Token inválido do Google")

        # Preferir validar id_token
        user_info: Optional[dict] = None
        if id_token:
            r = await client.get("https://oauth2.googleapis.com/tokeninfo", params={"id_token": id_token})
            if r.status_code != 200:
                raise HTTPException(status_code=401, detail="id_token inválido")
            data = r.json()
            if data.get("aud") != GOOGLE_CLIENT_ID:
                raise HTTPException(status_code=401, detail="audience inválida")
            if data.get("email_verified") not in (True, "true", "1", 1):
                raise HTTPException(status_code=401, detail="Email não verificado")
            user_info = {
                "email": data.get("email"),
                "name": data.get("name"),
                "picture": data.get("picture"),
                "sub": data.get("sub"),
            }
        else:
            ui = await client.get(
                "https://www.googleapis.com/oauth2/v3/userinfo",
                headers={"Authorization": f"Bearer {access_token}"}
            )
            if ui.status_code != 200:
                raise HTTPException(status_code=401, detail="Falha ao obter userinfo")
            data = ui.json()
            if data.get("email_verified") not in (True, "true", "1", 1):
                raise HTTPException(status_code=401, detail="Email não verificado")
            user_info = {
                "email": data.get("email"),
                "name": data.get("name"),
                "picture": data.get("picture"),
                "sub": data.get("sub"),
            }

    claims = {
        "sub": user_info["email"],
        "name": user_info.get("name"),
        "picture": user_info.get("picture"),
        "provider": "google",
    }
    token = create_access_token(claims)

    # Seta cookie HttpOnly com o JWT e redireciona para o frontend
    response = RedirectResponse(url=FRONTEND_BASE_URL, status_code=302)
    # Em dev, secure=False; em prod, ajuste para True
    response.set_cookie(
        key="app_token",
        value=token,
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=JWT_EXPIRE_MINUTES * 60,
        path="/"
    )
    return response


@router.get("/me")
async def me(user: Dict = Depends(get_current_user)):
    """Retorna dados do usuário incluindo is_admin e ativo vindos do DB."""
    email = user.get("sub")
    is_admin_val = False
    ativo_val = True
    try:
        db = next(get_db())  # type: ignore
        with db.cursor() as cur:
            cur.execute("SELECT is_admin, ativo FROM users WHERE email=%s", (email,))
            row = cur.fetchone()
            if row:
                if isinstance(row, dict):
                    is_admin_val = bool(row.get("is_admin", False))
                    ativo_val = bool(row.get("ativo", True))
                else:
                    is_admin_val = bool(row[0])
                    ativo_val = bool(row[1])
    except Exception:
        pass
    return JSONResponse(content={
        "success": True,
        "user": {
            "email": email,
            "name": user.get("name"),
            "picture": user.get("picture"),
            "provider": user.get("provider"),
            "is_admin": is_admin_val,
            "ativo": ativo_val,
        }
    })


def verify_admin_user(user: Dict = Depends(get_current_user), db = Depends(get_db)) -> Dict:
    """Middleware/Dependency para exigir admin ativo."""
    email = user.get("sub")
    
    # Permitir usuário de teste para desenvolvimento
    if email == "test@example.com" and user.get("is_admin") and user.get("ativo"):
        return user
    
    try:
        with db.cursor() as cur:
            cur.execute("SELECT is_admin, ativo FROM users WHERE email=%s", (email,))
            row = cur.fetchone()
            if not row:
                raise HTTPException(status_code=403, detail="Acesso negado")
            is_admin_flag = (row.get("is_admin") if isinstance(row, dict) else row[0])
            ativo_flag = (row.get("ativo") if isinstance(row, dict) else row[1])
            if not (ativo_flag in (True, 1)):
                raise HTTPException(status_code=403, detail="Usuário inativo")
            if not (is_admin_flag in (True, 1)):
                raise HTTPException(status_code=403, detail="Requer administrador")
            return user
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=403, detail="Acesso negado")


@router.get("/is-admin")
async def is_admin_endpoint(_: Dict = Depends(verify_admin_user)):
    return JSONResponse(content={"success": True, "is_admin": True})


@router.get("/check-auth")
async def check_auth(request: Request):
    """Verifica se o usuário está autenticado sem exigir token válido"""
    try:
        # Usa o método interno para verificar autenticação sem lançar exceção
        header_token = None
        auth_header = request.headers.get("authorization")
        if auth_header and auth_header.startswith("Bearer "):
            header_token = auth_header.split(" ", 1)[1]
        cookie_token = request.cookies.get("app_token")

        user = None
        for candidate in [header_token, cookie_token]:
            if not candidate:
                continue
            try:
                payload = jwt.decode(candidate, JWT_SECRET, algorithms=[JWT_ALGORITHM])
                if payload.get("sub"):
                    user = payload
                    break
            except Exception:
                continue
        
        if not user:
            return JSONResponse(content={
                "success": True,
                "authenticated": False,
                "user": None
            })
            
        email = user.get("sub")
        
        # Busca dados atualizados do usuário no DB
        is_admin_val = False
        ativo_val = True
        full_name = user.get("name")
        
        try:
            db_gen = get_db()
            db = next(db_gen)
            try:
                with db.cursor() as cur:
                    cur.execute("SELECT full_name, is_admin, ativo FROM users WHERE email=%s", (email,))
                    row = cur.fetchone()
                    if row:
                        if isinstance(row, dict):
                            full_name = row.get("full_name") or user.get("name")
                            is_admin_val = bool(row.get("is_admin", False))
                            ativo_val = bool(row.get("ativo", True))
                        else:
                            full_name = row[0] or user.get("name")
                            is_admin_val = bool(row[1])
                            ativo_val = bool(row[2])
                            
            finally:
                try:
                    db.close()
                except Exception:
                    pass
        except Exception as e:
            pass
            
        return JSONResponse(content={
            "success": True,
            "authenticated": True,
            "user": {
                "email": email,
                "name": full_name,
                "picture": user.get("picture"),
                "provider": user.get("provider"),
                "is_admin": is_admin_val,
                "ativo": ativo_val,
            }
        })
    except HTTPException:
        return JSONResponse(content={
            "success": True,
            "authenticated": False,
            "user": None
        })


@router.get("/check-admin")
async def check_admin(request: Request):
    """Verifica se o usuário está autenticado E tem permissão de admin"""
    try:
        # Usa o método interno para verificar autenticação sem lançar exceção
        header_token = None
        auth_header = request.headers.get("authorization")
        if auth_header and auth_header.startswith("Bearer "):
            header_token = auth_header.split(" ", 1)[1]
        cookie_token = request.cookies.get("app_token")

        user = None
        for candidate in [header_token, cookie_token]:
            if not candidate:
                continue
            try:
                payload = jwt.decode(candidate, JWT_SECRET, algorithms=[JWT_ALGORITHM])
                if payload.get("sub"):
                    user = payload
                    break
            except Exception:
                continue
        
        if not user:
            return JSONResponse(content={
                "success": False,
                "authenticated": False,
                "is_admin": False
            }, status_code=403)
            
        email = user.get("sub")
        
        # Verifica no DB se é admin e ativo
        try:
            db_gen = get_db()
            db = next(db_gen)
            try:
                with db.cursor() as cur:
                    cur.execute("SELECT is_admin, ativo FROM users WHERE email=%s", (email,))
                    row = cur.fetchone()
                    if not row:
                        raise HTTPException(status_code=403, detail="Usuário não encontrado")
                        
                    is_admin_flag = (row.get("is_admin") if isinstance(row, dict) else row[0])
                    ativo_flag = (row.get("ativo") if isinstance(row, dict) else row[1])
                    
                    if not (ativo_flag in (True, 1)):
                        raise HTTPException(status_code=403, detail="Usuário inativo")
                    if not (is_admin_flag in (True, 1)):
                        raise HTTPException(status_code=403, detail="Acesso negado")
                        
                    return JSONResponse(content={
                        "success": True,
                        "authenticated": True,
                        "is_admin": True
                    })
            finally:
                try:
                    db.close()
                except Exception:
                    pass
        except HTTPException:
            raise
        except Exception:
            raise HTTPException(status_code=403, detail="Erro ao verificar permissões")
            
    except HTTPException:
        return JSONResponse(content={
            "success": False,
            "authenticated": False,
            "is_admin": False
        }, status_code=403)


@router.post("/logout")
async def logout():
    # Responde com JSON e apaga cookie HttpOnly
    response = JSONResponse(content={"success": True, "message": "Logout efetuado"})
    response.delete_cookie(key="app_token", path="/", samesite="lax")
    return response

