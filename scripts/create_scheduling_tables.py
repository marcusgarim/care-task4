#!/usr/bin/env python3
"""
Script para criar/atualizar tabelas do sistema de agendamento
Baseado nas lógicas encontradas no arquivo N.py
"""

import os
import sys
import psycopg
from psycopg.rows import dict_row

# Adiciona o diretório raiz ao path para importar módulos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def get_db_connection():
    """Conecta ao banco PostgreSQL usando as credenciais do ambiente"""
    try:
        conn = psycopg.connect(
            host=os.getenv('PGHOST', 'general-care-db.postgres.database.azure.com'),
            user=os.getenv('PGUSER', 'generalcare'),
            password=os.getenv('PGPASSWORD', "47=y85Y/u'4J"),
            dbname=os.getenv('PGDATABASE', 'smart-assistant'),
            port=int(os.getenv('PGPORT', '5432'))
        )
        return conn
    except Exception as e:
        print(f"Erro ao conectar no banco: {e}")
        return None

def create_scheduling_tables():
    """Cria as tabelas necessárias para o sistema de agendamento"""
    
    sql_commands = [
        # 1. Tabela de clientes
        """
        CREATE TABLE IF NOT EXISTS clientes (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            nome VARCHAR(255) NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            telefone VARCHAR(50),
            data_nascimento DATE,
            endereco TEXT,
            observacoes TEXT,
            ativo INTEGER DEFAULT 1,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP NULL
        );
        """,
        
        # 2. Atualizar tabela de profissionais para incluir campos necessários
        """
        ALTER TABLE profissionais 
        ADD COLUMN IF NOT EXISTS email VARCHAR(255),
        ADD COLUMN IF NOT EXISTS telefone VARCHAR(50),
        ADD COLUMN IF NOT EXISTS endereco TEXT;
        """,
        
        # 3. Criar índice único para email de profissionais (se não existir)
        """
        CREATE UNIQUE INDEX IF NOT EXISTS idx_profissionais_email 
        ON profissionais(email) WHERE email IS NOT NULL;
        """,
        
        # 4. Evoluir a tabela horarios_disponiveis para ser mais flexível
        """
        CREATE TABLE IF NOT EXISTS disponibilidades_profissional (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            profissional_id INTEGER NOT NULL REFERENCES profissionais(id) ON DELETE CASCADE,
            dia_semana INTEGER NOT NULL, -- 1=Segunda, 2=Terça, ..., 7=Domingo
            hora_inicio TIME,
            hora_fim TIME,
            intervalo_inicio TIME, -- Início do intervalo (almoço/descanso)
            intervalo_fim TIME,    -- Fim do intervalo
            tipo_atendimento VARCHAR(20) DEFAULT 'presencial', -- presencial, remoto, hibrido, indisponivel
            duracao_consulta INTEGER DEFAULT 60, -- duração padrão em minutos
            ativo INTEGER DEFAULT 1,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP NULL
        );
        """,
        
        # 5. Tabela de agendamentos
        """
        CREATE TABLE IF NOT EXISTS agendamentos (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            cliente_id INTEGER REFERENCES clientes(id),
            profissional_id INTEGER NOT NULL REFERENCES profissionais(id),
            servico_id INTEGER REFERENCES servicos_clinica(id),
            data_consulta DATE NOT NULL,
            hora_inicio TIME NOT NULL,
            hora_fim TIME NOT NULL,
            tipo_atendimento VARCHAR(20) NOT NULL, -- presencial, remoto, hibrido
            status INTEGER DEFAULT 0, -- 0=agendado, 1=confirmado, 2=realizado, 3=cancelado, 4=falta
            observacao TEXT,
            valor NUMERIC(10,2),
            forma_pagamento_id INTEGER REFERENCES formas_pagamento(id),
            data_agendamento TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            data_confirmacao TIMESTAMP NULL,
            data_realizacao TIMESTAMP NULL,
            cancelado_por VARCHAR(100), -- usuario, cliente, sistema
            motivo_cancelamento TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP NULL
        );
        """,
        
        # 6. Tabela para bloqueios de agenda (feriados, férias, etc.)
        """
        CREATE TABLE IF NOT EXISTS bloqueios_agenda (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            profissional_id INTEGER REFERENCES profissionais(id), -- NULL para bloqueio geral
            data_inicio DATE NOT NULL,
            data_fim DATE NOT NULL,
            hora_inicio TIME, -- NULL para dia inteiro
            hora_fim TIME,    -- NULL para dia inteiro
            tipo VARCHAR(50) NOT NULL, -- feriado, ferias, licenca, reuniao, etc.
            descricao TEXT,
            recorrente INTEGER DEFAULT 0, -- 0=não, 1=semanal, 2=mensal, 3=anual
            ativo INTEGER DEFAULT 1,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        """,
        
        # 7. Índices para performance
        """
        CREATE INDEX IF NOT EXISTS idx_clientes_email ON clientes(email);
        CREATE INDEX IF NOT EXISTS idx_disponibilidades_profissional 
        ON disponibilidades_profissional(profissional_id, dia_semana);
        CREATE INDEX IF NOT EXISTS idx_agendamentos_data 
        ON agendamentos(data_consulta, profissional_id);
        CREATE INDEX IF NOT EXISTS idx_agendamentos_cliente 
        ON agendamentos(cliente_id);
        CREATE INDEX IF NOT EXISTS idx_agendamentos_status 
        ON agendamentos(status);
        CREATE INDEX IF NOT EXISTS idx_bloqueios_data 
        ON bloqueios_agenda(data_inicio, data_fim);
        """,
        
        # 8. Inserir alguns dados de exemplo para disponibilidades
        """
        INSERT INTO disponibilidades_profissional (profissional_id, dia_semana, hora_inicio, hora_fim, intervalo_inicio, intervalo_fim, tipo_atendimento, duracao_consulta)
        SELECT 
            p.id,
            generate_series(1, 5) as dia_semana, -- Segunda a Sexta
            '08:00'::time as hora_inicio,
            '18:00'::time as hora_fim,
            '12:00'::time as intervalo_inicio,
            '13:00'::time as intervalo_fim,
            'presencial' as tipo_atendimento,
            60 as duracao_consulta
        FROM profissionais p
        WHERE p.ativo = 1 
        AND NOT EXISTS (
            SELECT 1 FROM disponibilidades_profissional dp 
            WHERE dp.profissional_id = p.id
        )
        ON CONFLICT DO NOTHING;
        """,
        
        # 9. Inserir alguns clientes de exemplo
        """
        INSERT INTO clientes (nome, email, telefone) VALUES
        ('João Silva', 'joao.silva@email.com', '(11) 99999-1111'),
        ('Maria Santos', 'maria.santos@email.com', '(11) 99999-2222'),
        ('Pedro Oliveira', 'pedro.oliveira@email.com', '(11) 99999-3333')
        ON CONFLICT (email) DO NOTHING;
        """,
        
        # 10. Inserir alguns bloqueios de exemplo
        """
        INSERT INTO bloqueios_agenda (data_inicio, data_fim, tipo, descricao) VALUES
        ('2024-12-25', '2024-12-25', 'feriado', 'Natal'),
        ('2025-01-01', '2025-01-01', 'feriado', 'Ano Novo'),
        ('2025-04-21', '2025-04-21', 'feriado', 'Tiradentes')
        ON CONFLICT DO NOTHING;
        """
    ]
    
    conn = get_db_connection()
    if not conn:
        return False
    
    try:
        with conn.cursor() as cur:
            for i, sql in enumerate(sql_commands):
                try:
                    print(f"Executando comando {i+1}/{len(sql_commands)}...")
                    cur.execute(sql)
                    conn.commit()
                    print(f"Comando {i+1} executado com sucesso")
                except Exception as e:
                    print(f"Erro no comando {i+1}: {e}")
                    conn.rollback()
                    # Continua para o próximo comando
        
        print("\n Script de criação de tabelas concluído!")
        return True
        
    except Exception as e:
        print(f"Erro geral: {e}")
        return False
    finally:
        conn.close()

def verify_tables():
    """Verifica se as tabelas foram criadas corretamente"""
    conn = get_db_connection()
    if not conn:
        return
    
    try:
        with conn.cursor(row_factory=dict_row) as cur:
            # Lista tabelas relacionadas ao agendamento
            cur.execute("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name IN ('clientes', 'disponibilidades_profissional', 'agendamentos', 'bloqueios_agenda')
                ORDER BY table_name;
            """)
            
            tables = cur.fetchall()
            print("\n Tabelas de agendamento criadas:")
            for table in tables:
                print(f"   {table['table_name']}")
            
            # Contar registros
            print("\n Resumo de dados:")
            for table in ['profissionais', 'clientes', 'disponibilidades_profissional', 'agendamentos']:
                try:
                    cur.execute(f"SELECT COUNT(*) as total FROM {table}")
                    result = cur.fetchone()
                    print(f"  {table}: {result['total']} registros")
                except:
                    print(f"  {table}: tabela não encontrada")
                    
    except Exception as e:
        print(f"Erro ao verificar tabelas: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    print(" Iniciando criação das tabelas de agendamento...")
    
    # Definir variáveis de ambiente se não estiverem definidas
    if not os.getenv('PGHOST'):
        os.environ['PGHOST'] = 'general-care-db.postgres.database.azure.com'
        os.environ['PGUSER'] = 'generalcare'
        os.environ['PGPASSWORD'] = "47=y85Y/u'4J"
        os.environ['PGDATABASE'] = 'smart-assistant'
        os.environ['PGPORT'] = '5432'
    
    success = create_scheduling_tables()
    if success:
        verify_tables()
    else:
        print(" Falha na criação das tabelas")
        sys.exit(1)
