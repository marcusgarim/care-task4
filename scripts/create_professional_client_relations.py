#!/usr/bin/env python3
"""
Script para criar tabela de relacionamentos profissional-cliente
Baseado nas logicas encontradas no arquivo N.py
"""

import os
import sys
import psycopg
from psycopg.rows import dict_row

# Adiciona o diretório raiz ao path para importar módulos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def get_db_connection():
    """Conecta ao banco PostgreSQL usando as credenciais do ambiente"""
    try:
        conn = psycopg.connect(
            host=os.getenv('PGHOST', 'general-care-db.postgres.database.azure.com'),
            user=os.getenv('PGUSER', 'generalcare'),
            password=os.getenv('PGPASSWORD', "47=y85Y/u'4J"),
            dbname=os.getenv('PGDATABASE', 'smart-assistant'),
            port=int(os.getenv('PGPORT', '5432'))
        )
        return conn
    except Exception as e:
        print(f"Erro ao conectar no banco: {e}")
        return None

def create_professional_client_relations():
    """Cria a tabela de relacionamentos profissional-cliente"""
    
    sql_commands = [
        # 1. Criar tabela de relacionamentos profissional-cliente
        """
        CREATE TABLE IF NOT EXISTS profissional_cliente (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            profissional_id INTEGER NOT NULL REFERENCES profissionais(id) ON DELETE CASCADE,
            cliente_id INTEGER NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
            ativo INTEGER DEFAULT 1,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP NULL,
            UNIQUE(profissional_id, cliente_id)
        );
        """,
        
        # 2. Criar índices para performance
        """
        CREATE INDEX IF NOT EXISTS idx_profissional_cliente_profissional 
        ON profissional_cliente(profissional_id);
        CREATE INDEX IF NOT EXISTS idx_profissional_cliente_cliente 
        ON profissional_cliente(cliente_id);
        CREATE INDEX IF NOT EXISTS idx_profissional_cliente_ativo 
        ON profissional_cliente(ativo);
        """,
        
        # 3. Criar relações automaticamente baseadas nos agendamentos existentes
        """
        INSERT INTO profissional_cliente (profissional_id, cliente_id, ativo)
        SELECT DISTINCT a.profissional_id, a.cliente_id, 1
        FROM agendamentos a
        WHERE a.cliente_id IS NOT NULL
        AND NOT EXISTS (
            SELECT 1 FROM profissional_cliente pc 
            WHERE pc.profissional_id = a.profissional_id 
            AND pc.cliente_id = a.cliente_id
        )
        ON CONFLICT (profissional_id, cliente_id) DO NOTHING;
        """,
        
        # 4. Criar função para atualizar relacionamentos automaticamente
        """
        CREATE OR REPLACE FUNCTION update_professional_client_relation()
        RETURNS TRIGGER AS $$
        BEGIN
            -- Quando um agendamento é criado, criar relação se não existir
            IF TG_OP = 'INSERT' AND NEW.cliente_id IS NOT NULL THEN
                INSERT INTO profissional_cliente (profissional_id, cliente_id, ativo)
                VALUES (NEW.profissional_id, NEW.cliente_id, 1)
                ON CONFLICT (profissional_id, cliente_id) DO UPDATE SET
                    ativo = 1,
                    updated_at = CURRENT_TIMESTAMP;
            END IF;
            
            RETURN COALESCE(NEW, OLD);
        END;
        $$ LANGUAGE plpgsql;
        """,
        
        # 5. Criar trigger para automatizar relacionamentos
        """
        DROP TRIGGER IF EXISTS trigger_update_professional_client_relation ON agendamentos;
        CREATE TRIGGER trigger_update_professional_client_relation
            AFTER INSERT ON agendamentos
            FOR EACH ROW
            EXECUTE FUNCTION update_professional_client_relation();
        """
    ]
    
    conn = get_db_connection()
    if not conn:
        return False
    
    try:
        with conn.cursor() as cur:
            for i, sql in enumerate(sql_commands):
                try:
                    print(f"Executando comando {i+1}/{len(sql_commands)}...")
                    cur.execute(sql)
                    conn.commit()
                    print(f"Comando {i+1} executado com sucesso")
                except Exception as e:
                    print(f"Erro no comando {i+1}: {e}")
                    conn.rollback()
                    # Continua para o próximo comando
        
        print("\nScript de criação de relacionamentos concluído!")
        return True
        
    except Exception as e:
        print(f"Erro geral: {e}")
        return False
    finally:
        conn.close()

def verify_relations():
    """Verifica se a tabela foi criada corretamente"""
    conn = get_db_connection()
    if not conn:
        return
    
    try:
        with conn.cursor(row_factory=dict_row) as cur:
            # Verificar se tabela existe
            cur.execute("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'profissional_cliente'
            """)
            
            if cur.fetchone():
                print("Tabela profissional_cliente criada com sucesso")
                
                # Contar relacionamentos
                cur.execute("SELECT COUNT(*) as total FROM profissional_cliente")
                result = cur.fetchone()
                print(f"Total de relacionamentos: {result['total']}")
                
                # Contar relacionamentos ativos
                cur.execute("SELECT COUNT(*) as total FROM profissional_cliente WHERE ativo = 1")
                result = cur.fetchone()
                print(f"Relacionamentos ativos: {result['total']}")
                
                # Mostrar alguns exemplos
                cur.execute("""
                    SELECT 
                        p.nome as profissional,
                        c.nome as cliente,
                        pc.ativo,
                        pc.created_at
                    FROM profissional_cliente pc
                    JOIN profissionais p ON pc.profissional_id = p.id
                    JOIN clientes c ON pc.cliente_id = c.id
                    ORDER BY pc.created_at DESC
                    LIMIT 5
                """)
                
                exemplos = cur.fetchall()
                if exemplos:
                    print("\nExemplos de relacionamentos:")
                    for ex in exemplos:
                        status = "Ativo" if ex['ativo'] else "Inativo"
                        print(f"  {ex['profissional']} <-> {ex['cliente']} ({status})")
            else:
                print("Falha na criação da tabela profissional_cliente")
                    
    except Exception as e:
        print(f"Erro ao verificar relacionamentos: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    print("Iniciando criação de relacionamentos profissional-cliente...")
    
    # Definir variáveis de ambiente se não estiverem definidas
    if not os.getenv('PGHOST'):
        os.environ['PGHOST'] = 'general-care-db.postgres.database.azure.com'
        os.environ['PGUSER'] = 'generalcare'
        os.environ['PGPASSWORD'] = "47=y85Y/u'4J"
        os.environ['PGDATABASE'] = 'smart-assistant'
        os.environ['PGPORT'] = '5432'
    
    success = create_professional_client_relations()
    if success:
        verify_relations()
    else:
        print("Falha na criação dos relacionamentos")
        sys.exit(1)
